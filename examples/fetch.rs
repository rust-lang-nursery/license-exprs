#[macro_use]
extern crate failure;
extern crate serde_json;
extern crate reqwest;

use std::io::{self, Write};
use std::{env, process};

use failure::Error;
use serde_json::{Value, map};

type Map = map::Map<String, Value>;

fn download<F>(uri: &str, mut action: F, debug: bool) -> Result<(), Error>
    where F: FnMut(Map) -> Result<(), Error> {
    let json: Value = reqwest::get(uri)?.json()?;
    let json = if let Value::Object(m) = json {
        m
    } else {
        return Err(format_err!("Malformed JSON: {:?}", json));
    };

    if debug {
        writeln!(io::stderr(), "#json == {}", json.len())?;
        writeln!(io::stderr(), "License list version {}", get(&json, "licenseListVersion")?)?;
    }
    action(json)
}

fn get<'a>(m: &'a Map, k: &str) -> Result<&'a Value, Error> {
    if let Some(v) = m.get(k) {
        Ok(v)
    } else {
        Err(format_err!("Malformed JSON: {:?} lacks {}", m, k))
    }
}

fn main1(args: &[String]) -> Result<(), Error> {
    let mut upstream_tag = "master";
    let mut debug = false;
    for e in args {
        match e.as_str() {
            "-d" => {
                debug = true;
            },
            s if s.starts_with('v') => {
                upstream_tag = &s;
            },
            _ => {
                return Err(format_err!("Unknown option {:?}", e));
            }
        }
    }

    let mut stdout = io::stdout();
    let mut stderr = io::stderr();

    if upstream_tag == "master" {
        writeln!(stderr, "WARN: fetching data from the master branch of spdx/license-list-data; \
                          consider specifying a tag (e.g. v3.0)")?;
    } else {
        writeln!(stderr, "Using tag {:?}", upstream_tag)?;
    }

    writeln!(stdout, "\
/*
 * whitelist fetched from https://github.com/spdx/license-list-data
 *
 * AUTO-GENERATED BY examples/fetch.rs
 * DO NOT MODIFY
 *
 * cargo run --example fetch-license-list-from-spdx v3.0 > spdx.rs
 */
")?;

    let licenses_json_uri =
        format!("https://raw.githubusercontent.com/spdx/license-list-data/{}/json/licenses.json",
                upstream_tag);
    download(&licenses_json_uri, |json| {
        let licenses = get(&json, "licenses")?;
        let licenses = if let &Value::Array(ref v) = licenses {
            v
        } else {
            return Err(format_err!("Malformed JSON: {:?}", licenses));
        };
        writeln!(stderr, "#licenses == {}", licenses.len())?;

        let mut v = vec![];
        for lic in licenses.iter() {
            let lic = if let Value::Object(ref m) = *lic {
                m
            } else {
                return Err(format_err!("Malformed JSON: {:?}", lic));
            };
            if debug {
                writeln!(stderr, "{:?},{:?}", get(&lic, "licenseId"), get(&lic, "name"))?;
            }

            let lic_id = get(&lic, "licenseId")?;
            if let &Value::String(ref s) = lic_id {
                v.push(s);
            } else {
                return Err(format_err!("Malformed JSON: {:?}", lic_id));
            }
        }
        v.sort();

        let lic_list_ver = get(&json, "licenseListVersion")?;
        if let &Value::String(ref s) = lic_list_ver {
            writeln!(stdout, "pub const VERSION: &'static str = {:?};", s)?;
        } else {
            return Err(format_err!("Malformed JSON: {:?}", lic_list_ver));
        }
        writeln!(stdout)?;
        writeln!(stdout, "pub const LICENSES: &'static [&'static str] = &[")?;
        for lic in v.iter() {
            writeln!(stdout, "    \"{}\",", lic)?;
        }
        writeln!(stdout, "];")?;

        Ok(())
    }, debug)?;

    writeln!(stdout)?;

    let exceptions_json_uri =
        format!("https://raw.githubusercontent.com/spdx/license-list-data/{}/json/exceptions.json",
                upstream_tag);
    download(&exceptions_json_uri, |json| {
        let exceptions = get(&json, "exceptions")?;
        let exceptions = if let &Value::Array(ref v) = exceptions {
            v
        } else {
            return Err(format_err!("Malformed JSON: {:?}", exceptions));
        };
        writeln!(stderr, "#exceptions == {}", exceptions.len())?;

        let mut v = vec![];
        for exc in exceptions.iter() {
            let exc = if let Value::Object(ref m) = *exc {
                m
            } else {
                return Err(format_err!("Malformed JSON: {:?}", exc))
            };
            if debug {
                writeln!(stderr, "{:?},{:?}", get(&exc, "licenseExceptionId"), get(&exc, "name"))?;
            }

            let lic_exc_id = get(&exc, "licenseExceptionId")?;
            if let &Value::String(ref s) = lic_exc_id {
                v.push(s);
            } else {
                return Err(format_err!("Malformed JSON: {:?}", lic_exc_id));
            };
        }

        writeln!(stdout, "pub const EXCEPTIONS: &'static [&'static str] = &[")?;
        v.sort();
        for exc in v.iter() {
            writeln!(stdout, "    \"{}\",", exc)?;
        }
        writeln!(stdout, "];")?;

        Ok(())
    }, debug)?;

    Ok(())
}

fn main() {
    let args = env::args().skip(1).collect::<Vec<_>>();
    if let Err(ref e) = main1(args.as_ref()) {
        writeln!(io::stderr(), "{}", e).expect("writeln to stderr");
        process::exit(1);
    }
}
